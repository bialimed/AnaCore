

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>anacore.msi.base &mdash; AnaCore  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/anacore.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> AnaCore
          

          
            
            <img src="../../../_static/anacore_logo_40deg.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../anacore.html">AnaCore package</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">AnaCore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>anacore.msi.base</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for anacore.msi.base</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Classes and functions for manipulating/processing MSI information (status, data, locus, ...).&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Frederic Escudie&#39;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s1">&#39;Copyright (C) 2018 IUCT-O&#39;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s1">&#39;GNU General Public License&#39;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s1">&#39;1.7.0&#39;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s1">&#39;escudie.frederic@iuct-oncopole.fr&#39;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s1">&#39;prod&#39;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>


<div class="viewcode-block" id="toDict"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.toDict">[docs]</a><span class="k">def</span> <span class="nf">toDict</span><span class="p">(</span><span class="n">msi_object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retuns a dictionary representing the object. This method is used in json.dump in argument named &quot;default&quot; for recursively convert an object to json.</span>

<span class="sd">    :param msi_object: The object to convert.</span>
<span class="sd">    :type msi_object: a class of anacore.msi library</span>
<span class="sd">    :return: The dictionary representing the object.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">msi_object</span><span class="o">.</span><span class="vm">__dict__</span></div>


<div class="viewcode-block" id="Status"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.Status">[docs]</a><span class="k">class</span> <span class="nc">Status</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Status for samples (MSISplRes) and loci (LocusRes) in anacore.msi library.&quot;&quot;&quot;</span>

    <span class="n">stable</span> <span class="o">=</span> <span class="s2">&quot;MSS&quot;</span>
    <span class="n">unstable</span> <span class="o">=</span> <span class="s2">&quot;MSI&quot;</span>
    <span class="n">undetermined</span> <span class="o">=</span> <span class="s2">&quot;Undetermined&quot;</span>  <span class="c1"># Cannot be determined</span>
    <span class="n">none</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Not evaluated</span>

<div class="viewcode-block" id="Status.authorizedValues"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.Status.authorizedValues">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">authorizedValues</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return the values authorized for stability status.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">attr_value</span> <span class="k">for</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">attr_value</span> <span class="ow">in</span> <span class="n">Status</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">attr_name</span> <span class="o">!=</span> <span class="s2">&quot;authorizedValues&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">attr_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)]</span></div></div>


<div class="viewcode-block" id="MSILocus"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSILocus">[docs]</a><span class="k">class</span> <span class="nc">MSILocus</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Manage a locus of a microsatellite (name, position and stability status).&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">results</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of MSILocus.</span>

<span class="sd">        :param position: The position of the locus with format chr:start-end (the start is 0-based).</span>
<span class="sd">        :type position: str</span>
<span class="sd">        :param name: The name of the locus (for example: NR21).</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param results: The results of the locus indexed by the name of the method used to produce these results.</span>
<span class="sd">        :type results: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: MSILocus</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">results</span>

<div class="viewcode-block" id="MSILocus.delResult"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSILocus.delResult">[docs]</a>    <span class="k">def</span> <span class="nf">delResult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete result from locus.</span>

<span class="sd">        :param result_id: The ID used for index the results to delete.</span>
<span class="sd">        :type result_id: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">result_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="MSILocus.fromDict"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSILocus.fromDict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fromDict</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of MSILocus from a dict. This method is used for load instance from JSON.</span>

<span class="sd">        :param data: The locus information.</span>
<span class="sd">        :type data: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: MSILocus</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cleaned_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;results&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="s2">&quot;_class&quot;</span> <span class="ow">in</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;_class&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;LocusResPairsCombi&quot;</span><span class="p">:</span>
                    <span class="n">cleaned_data</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">][</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">LocusResPairsCombi</span><span class="o">.</span><span class="n">fromDict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;_class&quot;</span> <span class="ow">in</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;_class&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;LocusResDistrib&quot;</span><span class="p">:</span>
                    <span class="n">cleaned_data</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">][</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">LocusResDistrib</span><span class="o">.</span><span class="n">fromDict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cleaned_data</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">][</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">LocusRes</span><span class="o">.</span><span class="n">fromDict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MSILocus</span><span class="p">(</span><span class="o">**</span><span class="n">cleaned_data</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="LocusRes"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusRes">[docs]</a><span class="k">class</span> <span class="nc">LocusRes</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Manage the stability status for an anlysis of a locus.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of LocusRes.</span>

<span class="sd">        :param status: The status of the locus.</span>
<span class="sd">        :type status: msi.Status</span>
<span class="sd">        :param score: The confidence score on the status prediction (0 to 1).</span>
<span class="sd">        :type score: float</span>
<span class="sd">        :param data: The data used to predict the status (example: the size distribution).</span>
<span class="sd">        :type results: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: LocusRes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class</span> <span class="o">=</span> <span class="s2">&quot;LocusRes&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">score</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data</span>

<div class="viewcode-block" id="LocusRes.fromDict"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusRes.fromDict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fromDict</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of LocusRes from a dict. This method is used for load instance from JSON.</span>

<span class="sd">        :param data: The locus result information.</span>
<span class="sd">        :type data: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: LocusRes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cleaned_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;_class&quot;</span> <span class="ow">in</span> <span class="n">cleaned_data</span><span class="p">:</span>
            <span class="n">cleaned_data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_class&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LocusRes</span><span class="p">(</span><span class="o">**</span><span class="n">cleaned_data</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="LocusResDistrib"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusResDistrib">[docs]</a><span class="k">class</span> <span class="nc">LocusResDistrib</span><span class="p">(</span><span class="n">LocusRes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Manage the stability status for an anlysis of a locus containing the count by length.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of LocusResDistrib.</span>

<span class="sd">        :param status: The status of the locus.</span>
<span class="sd">        :type status: msi.Status</span>
<span class="sd">        :param score: The confidence score on the status prediction (0 to 1).</span>
<span class="sd">        :type score: float</span>
<span class="sd">        :param data: The data used to predict the status (example: the size distribution).</span>
<span class="sd">        :type results: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: LocusResDistrib</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class</span> <span class="o">=</span> <span class="s2">&quot;LocusResDistrib&quot;</span>

<div class="viewcode-block" id="LocusResDistrib.getCount"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusResDistrib.getCount">[docs]</a>    <span class="k">def</span> <span class="nf">getCount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of elements in size distribution.</span>

<span class="sd">        :return: The number of elements in size distribution.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nb_by_length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span></div>

<div class="viewcode-block" id="LocusResDistrib.getMinLength"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusResDistrib.getMinLength">[docs]</a>    <span class="k">def</span> <span class="nf">getMinLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum length of the locus.</span>

<span class="sd">        :return: The minimum length of the locus.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nb_by_length&quot;</span><span class="p">]])</span></div>

<div class="viewcode-block" id="LocusResDistrib.getMaxLength"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusResDistrib.getMaxLength">[docs]</a>    <span class="k">def</span> <span class="nf">getMaxLength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the maximum length of the locus.</span>

<span class="sd">        :return: The maximum length of the locus.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nb_by_length&quot;</span><span class="p">]])</span></div>

<div class="viewcode-block" id="LocusResDistrib.getDensePrct"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusResDistrib.getDensePrct">[docs]</a>    <span class="k">def</span> <span class="nf">getDensePrct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the percentage of elements by locus length for absolutely all lengths betwen start and end. The lengths with 0 are also indicated. The percentage is based on all the distribution not reduced at start and end.</span>

<span class="sd">        :param start: The first length of the returned distribution. [Default: the minimum length in the distribution]</span>
<span class="sd">        :type start: int</span>
<span class="sd">        :param end: The last length of the returned distribution. [Default: the maximum length in the distribution]</span>
<span class="sd">        :type end: int</span>
<span class="sd">        :return: The number of elements in each length.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nb_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCount</span><span class="p">()</span>
        <span class="n">dense_prct</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_count</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDenseCount</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="n">prct</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">nb_pairs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">prct</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_count</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="n">nb_pairs</span>
            <span class="n">dense_prct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prct</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dense_prct</span></div>

<div class="viewcode-block" id="LocusResDistrib.getDenseCount"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusResDistrib.getDenseCount">[docs]</a>    <span class="k">def</span> <span class="nf">getDenseCount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of elements by locus length for absolutely all lengths betwen start and end. The length with 0 are also indicated.</span>

<span class="sd">        :param start: The first length of the returned distribution. [Default: the minimum length in the distribution]</span>
<span class="sd">        :type start: int</span>
<span class="sd">        :param end: The last length of the returned distribution. [Default: the maximum length in the distribution]</span>
<span class="sd">        :type end: int</span>
<span class="sd">        :return: The number of elements in each length.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMinLength</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxLength</span><span class="p">()</span>
        <span class="n">dense_count</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_length</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">curr_length</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nb_by_length&quot;</span><span class="p">]:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nb_by_length&quot;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_length</span><span class="p">)]</span>
            <span class="n">dense_count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dense_count</span></div>

<div class="viewcode-block" id="LocusResDistrib.fromDict"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusResDistrib.fromDict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fromDict</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of LocusResDistrib from a dict. This method is used for load instance from JSON.</span>

<span class="sd">        :param data: The locus result information.</span>
<span class="sd">        :type data: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: LocusResDistrib</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cleaned_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;_class&quot;</span> <span class="ow">in</span> <span class="n">cleaned_data</span><span class="p">:</span>
            <span class="n">cleaned_data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_class&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LocusResDistrib</span><span class="p">(</span><span class="o">**</span><span class="n">cleaned_data</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="LocusResPairsCombi"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusResPairsCombi">[docs]</a><span class="k">class</span> <span class="nc">LocusResPairsCombi</span><span class="p">(</span><span class="n">LocusResDistrib</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Manage the stability status for an anlysis after reads pair combination of a locus.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of LocusResPairsCombi.</span>

<span class="sd">        :param status: The status of the locus.</span>
<span class="sd">        :type status: msi.Status</span>
<span class="sd">        :param score: The confidence score on the status prediction (0 to 1).</span>
<span class="sd">        :type score: float</span>
<span class="sd">        :param data: The data used to predict the status (example: the size distribution).</span>
<span class="sd">        :type results: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: LocusResPairsCombi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class</span> <span class="o">=</span> <span class="s2">&quot;LocusResPairsCombi&quot;</span>

<div class="viewcode-block" id="LocusResPairsCombi.getNbFrag"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusResPairsCombi.getNbFrag">[docs]</a>    <span class="k">def</span> <span class="nf">getNbFrag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of fragments in size distribution.</span>

<span class="sd">        :return: The number of fragments in size distribution.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCount</span><span class="p">()</span></div>

<div class="viewcode-block" id="LocusResPairsCombi.fromDict"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusResPairsCombi.fromDict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fromDict</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of LocusResPairsCombi from a dict. This method is used for load instance from JSON.</span>

<span class="sd">        :param data: The locus result information.</span>
<span class="sd">        :type data: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: LocusResPairsCombi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cleaned_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;_class&quot;</span> <span class="ow">in</span> <span class="n">cleaned_data</span><span class="p">:</span>
            <span class="n">cleaned_data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_class&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LocusResPairsCombi</span><span class="p">(</span><span class="o">**</span><span class="n">cleaned_data</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MSISplRes"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISplRes">[docs]</a><span class="k">class</span> <span class="nc">MSISplRes</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Manage the stability status for an anlysis of a sample.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of MSISplRes.</span>

<span class="sd">        :param status: The status of the sample.</span>
<span class="sd">        :type status: msi.Status</span>
<span class="sd">        :param score: The confidence score on the status prediction (0 to 1).</span>
<span class="sd">        :type score: float</span>
<span class="sd">        :param method: The name of the method used to predict status.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :param param: The parameters of the status prediction.</span>
<span class="sd">        :type param: dict</span>
<span class="sd">        :param version: The version of the method used to predict status.</span>
<span class="sd">        :type version: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: MSISplRes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">score</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span> <span class="o">=</span> <span class="n">param</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">version</span>

<div class="viewcode-block" id="MSISplRes.fromDict"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISplRes.fromDict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fromDict</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of MSISplRes from a dict. This method is used for load instance from JSON.</span>

<span class="sd">        :param data: The sample result information.</span>
<span class="sd">        :type data: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: MSISplRes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cleaned_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MSISplRes</span><span class="p">(</span><span class="o">**</span><span class="n">cleaned_data</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MSISample"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample">[docs]</a><span class="k">class</span> <span class="nc">MSISample</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Manage a sample in context of microsatellite instability analysis. This object contains information on loci and on analyses (at sample and loci levels).&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">loci</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">results</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of MSISample.</span>

<span class="sd">        :param name: The sample name.</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param loci: By ID (format: chr:start-end with start 0-based) the loci targeted in analysis.</span>
<span class="sd">        :type loci: dict</span>
<span class="sd">        :param results: By method name the analyses of sample status.</span>
<span class="sd">        :type results: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: MSISample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loci</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">loci</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">loci</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">results</span>

<div class="viewcode-block" id="MSISample.getLociMethods"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.getLociMethods">[docs]</a>    <span class="k">def</span> <span class="nf">getLociMethods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the different methods used in loci status analysis.</span>

<span class="sd">        :return: The names of the methods used in analyses of loci.</span>
<span class="sd">        :rtype: set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">methods</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_locus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loci</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">curr_method</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">methods</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr_method</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">methods</span></div>

<div class="viewcode-block" id="MSISample.addLocus"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.addLocus">[docs]</a>    <span class="k">def</span> <span class="nf">addLocus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locus</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add one locus to the sample.</span>

<span class="sd">        :param locus: The locus to add.</span>
<span class="sd">        :type locus: MSILocus</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">locus</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s2">&quot;MSILocus&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The class &quot;</span><span class="si">{}</span><span class="s1">&quot; cannot be used as locus for MSISample.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">locus</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">locus</span></div>

<div class="viewcode-block" id="MSISample.delLoci"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.delLoci">[docs]</a>    <span class="k">def</span> <span class="nf">delLoci</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locus_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete loci from the sample.</span>

<span class="sd">        :param locus_ids: The IDs of the loci to delete.</span>
<span class="sd">        :type locus_ids: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">locus_id</span> <span class="ow">in</span> <span class="n">locus_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delLocus</span><span class="p">(</span><span class="n">locus_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="MSISample.delLocus"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.delLocus">[docs]</a>    <span class="k">def</span> <span class="nf">delLocus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locus_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete one locus from the sample.</span>

<span class="sd">        :param locus_id: The ID of the locus to delete.</span>
<span class="sd">        :type locus_id: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loci</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">locus_id</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_getStatusByMethod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of loci status predicted by the selected method.</span>

<span class="sd">        :param method: The selected method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :return: The list of status.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">locus_id</span><span class="p">,</span> <span class="n">locus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loci</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
                <span class="n">status</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span>

<div class="viewcode-block" id="MSISample.getNbUnstable"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.getNbUnstable">[docs]</a>    <span class="k">def</span> <span class="nf">getNbUnstable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of loci predicted as unstable with the selected method.</span>

<span class="sd">        :param method: The selected method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :return: The number of unstable loci.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nb_unstable</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getStatusByMethod</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">curr_status</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr_status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">curr_status</span> <span class="o">==</span> <span class="n">Status</span><span class="o">.</span><span class="n">unstable</span><span class="p">:</span>
                <span class="n">nb_unstable</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">nb_unstable</span></div>

<div class="viewcode-block" id="MSISample.getNbStable"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.getNbStable">[docs]</a>    <span class="k">def</span> <span class="nf">getNbStable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of loci predicted as stable with the selected method.</span>

<span class="sd">        :param method: The selected method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :return: The number of stable loci.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nb_stable</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getStatusByMethod</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">curr_status</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr_status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">curr_status</span> <span class="o">==</span> <span class="n">Status</span><span class="o">.</span><span class="n">stable</span><span class="p">:</span>
                <span class="n">nb_stable</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">nb_stable</span></div>

<div class="viewcode-block" id="MSISample.getNbUndetermined"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.getNbUndetermined">[docs]</a>    <span class="k">def</span> <span class="nf">getNbUndetermined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of loci where the status is undetermined after prediction with the selected method.</span>

<span class="sd">        :param method: The selected method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :return: The number of undetermined loci.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nb_undetermined</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getStatusByMethod</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">curr_status</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr_status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">curr_status</span> <span class="o">==</span> <span class="n">Status</span><span class="o">.</span><span class="n">undetermined</span><span class="p">:</span>
                <span class="n">nb_undetermined</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">nb_undetermined</span></div>

<div class="viewcode-block" id="MSISample.getNbDetermined"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.getNbDetermined">[docs]</a>    <span class="k">def</span> <span class="nf">getNbDetermined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of loci with a prediction of status with the selected method.</span>

<span class="sd">        :param method: The selected method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :return: The number of determined loci.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nb_determined</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getStatusByMethod</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">curr_status</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr_status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">curr_status</span> <span class="o">!=</span> <span class="n">Status</span><span class="o">.</span><span class="n">undetermined</span><span class="p">:</span>
                <span class="n">nb_determined</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">nb_determined</span></div>

<div class="viewcode-block" id="MSISample.getNbProcessed"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.getNbProcessed">[docs]</a>    <span class="k">def</span> <span class="nf">getNbProcessed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of loci where the status has been evaluated for the sample with the selected method.</span>

<span class="sd">        :param method: The selected method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :return: The number of processed loci.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nb_processed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getStatusByMethod</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">curr_status</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr_status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nb_processed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">nb_processed</span></div>

<div class="viewcode-block" id="MSISample.getNbLoci"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.getNbLoci">[docs]</a>    <span class="k">def</span> <span class="nf">getNbLoci</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of loci in the sample.</span>

<span class="sd">        :param method: The selected method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :return: The number of loci.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loci</span><span class="p">)</span></div>

<div class="viewcode-block" id="MSISample.fromDict"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.fromDict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fromDict</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of MSISample from a dict. This method is used for load instance from JSON.</span>

<span class="sd">        :param data: The sample information.</span>
<span class="sd">        :type data: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: MSISample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cleaned_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># Loci</span>
        <span class="k">if</span> <span class="s2">&quot;loci&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">cleaned_data</span><span class="p">[</span><span class="s2">&quot;loci&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">locus_id</span><span class="p">,</span> <span class="n">locus</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;loci&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">cleaned_data</span><span class="p">[</span><span class="s2">&quot;loci&quot;</span><span class="p">][</span><span class="n">locus_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSILocus</span><span class="o">.</span><span class="n">fromDict</span><span class="p">(</span><span class="n">locus</span><span class="p">)</span>
        <span class="c1"># Results</span>
        <span class="k">if</span> <span class="s2">&quot;results&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">cleaned_data</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">cleaned_data</span><span class="p">[</span><span class="s2">&quot;results&quot;</span><span class="p">][</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">MSISplRes</span><span class="o">.</span><span class="n">fromDict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="c1"># Name</span>
        <span class="k">return</span> <span class="n">MSISample</span><span class="p">(</span><span class="o">**</span><span class="n">cleaned_data</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_getScoreCalculation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_status</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">undetermined_weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">locus_weight_is_score</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and return a confidence score for the sample status prediction. This score is calculation take into account each locus and his score with the following formula: sum(scores) / (len(scores) + nb_loci_undetermined * undetermined_weight).</span>

<span class="sd">        :param eval_status: The score is calculated for this status (msi.Status.stable or msi.Status.unstable). Except for undetermined_weight equals to 0 the score of the complementary status CANNOT be calculated by 1 - complementary score.</span>
<span class="sd">        :type eval_status: msi.Status</span>
<span class="sd">        :param method: The status of the loci are extracted from the results of this method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :param undetermined_weight: The weight of the undetermined loci in score calculation.</span>
<span class="sd">        :type undetermined_weight: float</span>
<span class="sd">        :param locus_weight_is_score: Use the prediction score of each locus as wheight of this locus in score calculation.</span>
<span class="sd">        :type locus_weight_is_score: bool</span>
<span class="sd">        :return: The prediction score. This score has a value between 0 and 1.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">nb_loci_undetermined</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">locus_id</span><span class="p">,</span> <span class="n">locus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loci</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">Status</span><span class="o">.</span><span class="n">undetermined</span><span class="p">:</span>
                    <span class="n">nb_loci_undetermined</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">eval_status</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">locus_weight_is_score</span> <span class="ow">and</span> <span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">score</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">score</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">Status</span><span class="o">.</span><span class="n">undetermined</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">locus_weight_is_score</span> <span class="ow">and</span> <span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">score</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">score</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">+</span> <span class="n">nb_loci_undetermined</span> <span class="o">*</span> <span class="n">undetermined_weight</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<div class="viewcode-block" id="MSISample.setScore"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.setScore">[docs]</a>    <span class="k">def</span> <span class="nf">setScore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">undetermined_weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">locus_weight_is_score</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and set a confidence score for the sample status prediction. This score is calculation take into account each locus and his score with the following formula: sum(scores) / (len(scores) + nb_loci_undetermined * undetermined_weight).</span>

<span class="sd">        :param method: Name of the selected method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :param undetermined_weight: The weight of the undetermined loci in score calculation.</span>
<span class="sd">        :type undetermined_weight: float</span>
<span class="sd">        :param locus_weight_is_score: Use the prediction score of each locus as wheight of this locus in score calculation.</span>
<span class="sd">        :type locus_weight_is_score: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spl_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">spl_res</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">Status</span><span class="o">.</span><span class="n">undetermined</span> <span class="ow">or</span> <span class="n">spl_res</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">Status</span><span class="o">.</span><span class="n">none</span><span class="p">:</span>
            <span class="n">spl_res</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spl_res</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getScoreCalculation</span><span class="p">(</span><span class="n">spl_res</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">undetermined_weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="MSISample.setStatusByInstabilityCount"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.setStatusByInstabilityCount">[docs]</a>    <span class="k">def</span> <span class="nf">setStatusByInstabilityCount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">min_voting_loci</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">instability_threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add status and score for the sample by number of unstable loci for the selected method.</span>

<span class="sd">        :param method: Name of the selected method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :param min_voting_loci: Minimum number of voting loci (stable + unstable) to determine the sample status. If the number of voting loci is lower than this value the status for the sample will be undetermined.</span>
<span class="sd">        :type min_voting_loci: int</span>
<span class="sd">        :param instability_threshold: If the number of unstable is superior or equal than this value the status of the sample will be unstable.</span>
<span class="sd">        :type instability_threshold: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">MSISplRes</span><span class="o">.</span><span class="n">fromDict</span><span class="p">({</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="n">Status</span><span class="o">.</span><span class="n">undetermined</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
            <span class="s1">&#39;score&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;param&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;aggregation_method&quot;</span><span class="p">:</span> <span class="s2">&quot;instability count&quot;</span><span class="p">,</span> <span class="s2">&quot;min_voting_loci&quot;</span><span class="p">:</span> <span class="n">min_voting_loci</span><span class="p">,</span> <span class="s2">&quot;instability_threshold&quot;</span><span class="p">:</span> <span class="n">instability_threshold</span><span class="p">},</span>
            <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span>
        <span class="p">})</span>
        <span class="n">nb_stable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNbStable</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">nb_unstable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNbUnstable</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">undetermined</span>
        <span class="k">if</span> <span class="n">nb_stable</span> <span class="o">+</span> <span class="n">nb_unstable</span> <span class="o">&gt;=</span> <span class="n">min_voting_loci</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nb_unstable</span> <span class="o">&gt;=</span> <span class="n">instability_threshold</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">unstable</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">stable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setScore</span><span class="p">(</span><span class="n">method</span><span class="p">)</span></div>

<div class="viewcode-block" id="MSISample.setStatusByInstabilityRatio"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.setStatusByInstabilityRatio">[docs]</a>    <span class="k">def</span> <span class="nf">setStatusByInstabilityRatio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">min_voting_loci</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">instability_threshold</span><span class="o">=</span><span class="mf">0.4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add status and score for the sample by ratio of unstable loci for the selected method.</span>

<span class="sd">        :param method: Name of the selected method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :param min_voting_loci: Minimum number of voting loci (stable + unstable) to determine the sample status. If the number of voting loci is lower than this value the status for the sample will be undetermined.</span>
<span class="sd">        :type min_voting_loci: int</span>
<span class="sd">        :param instability_threshold: If the ratio unstable/(stable + unstable) is superior or equal than this value the status of the sample will be unstable.</span>
<span class="sd">        :type instability_threshold: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">MSISplRes</span><span class="o">.</span><span class="n">fromDict</span><span class="p">({</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="n">Status</span><span class="o">.</span><span class="n">undetermined</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
            <span class="s1">&#39;score&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;param&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;aggregation_method&quot;</span><span class="p">:</span> <span class="s2">&quot;instability ratio&quot;</span><span class="p">,</span> <span class="s2">&quot;min_voting_loci&quot;</span><span class="p">:</span> <span class="n">min_voting_loci</span><span class="p">,</span> <span class="s2">&quot;instability_threshold&quot;</span><span class="p">:</span> <span class="n">instability_threshold</span><span class="p">},</span>
            <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span>
        <span class="p">})</span>
        <span class="n">nb_stable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNbStable</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">nb_unstable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNbUnstable</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">undetermined</span>
        <span class="k">if</span> <span class="n">nb_stable</span> <span class="o">+</span> <span class="n">nb_unstable</span> <span class="o">&gt;=</span> <span class="n">min_voting_loci</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nb_unstable</span> <span class="o">/</span> <span class="p">(</span><span class="n">nb_stable</span> <span class="o">+</span> <span class="n">nb_unstable</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">instability_threshold</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">unstable</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">stable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setScore</span><span class="p">(</span><span class="n">method</span><span class="p">)</span></div>

<div class="viewcode-block" id="MSISample.setStatusByMajority"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSISample.setStatusByMajority">[docs]</a>    <span class="k">def</span> <span class="nf">setStatusByMajority</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">min_voting_loci</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add status and score for the sample by consensus on loci results for the selected method.</span>

<span class="sd">        :param method: Name of the selected method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :param min_voting_loci: Minimum number of voting loci (stable + unstable) to determine the sample status. If the number of voting loci is lower than this value the status for the sample will be undetermined.</span>
<span class="sd">        :type min_voting_loci: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">MSISplRes</span><span class="o">.</span><span class="n">fromDict</span><span class="p">({</span>
            <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="n">Status</span><span class="o">.</span><span class="n">undetermined</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
            <span class="s1">&#39;score&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;param&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;aggregation_method&quot;</span><span class="p">:</span> <span class="s2">&quot;majority&quot;</span><span class="p">,</span> <span class="s2">&quot;min_voting_loci&quot;</span><span class="p">:</span> <span class="n">min_voting_loci</span><span class="p">},</span>
            <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="s2">&quot;1.0.0&quot;</span>
        <span class="p">})</span>
        <span class="n">nb_stable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNbStable</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">nb_unstable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNbUnstable</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nb_stable</span> <span class="o">+</span> <span class="n">nb_unstable</span> <span class="o">&gt;=</span> <span class="n">min_voting_loci</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">undetermined</span>
            <span class="k">if</span> <span class="n">nb_stable</span> <span class="o">&gt;</span> <span class="n">nb_unstable</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">stable</span>
            <span class="k">elif</span> <span class="n">nb_stable</span> <span class="o">&lt;</span> <span class="n">nb_unstable</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">unstable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setScore</span><span class="p">(</span><span class="n">method</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="LocusClassifier"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusClassifier">[docs]</a><span class="k">class</span> <span class="nc">LocusClassifier</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classifier for locus using MSISample objects.</span>

<span class="sd">    Synopsis:</span>
<span class="sd">        clf = LocusClassifier(locus_id, method_name, classifier)</span>
<span class="sd">        clf.fit(train_dataset)</span>
<span class="sd">        clf.predict(test_dataset)</span>
<span class="sd">        clf.predict_proba(test_dataset)</span>


<span class="sd">        clf = LocusClassifier(locus_id, method_name, classifier)</span>
<span class="sd">        clf.fit(train_dataset)</span>
<span class="sd">        clf.set_status(test_dataset)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locus_id</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">classifier</span><span class="p">,</span> <span class="n">model_method_name</span><span class="o">=</span><span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="n">data_method_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of LocusClassifier.</span>

<span class="sd">        :param locus_id: The ID (format: chr:start-end with start 0-based) of the loci targeted in analysis.</span>
<span class="sd">        :type locus_id: str</span>
<span class="sd">        :param method_name: By method name the analyses of sample status.</span>
<span class="sd">        :type method_name: dict</span>
<span class="sd">        :param classifier: The classifier used to predict status.</span>
<span class="sd">        :type classifier: A sklearn classifier object</span>
<span class="sd">        :param model_method_name: The name of the method used in models loci to store expected status and lengths distributions.</span>
<span class="sd">        :type model_method_name: str</span>
<span class="sd">        :param data_method_name: The data used for the prediction are extracted from the results of this method. By default the selected method is the same of the classifier method_name.</span>
<span class="sd">        :type data_method_name: str</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: LocusClassifier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">classifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_method_name</span> <span class="o">=</span> <span class="n">method_name</span> <span class="k">if</span> <span class="n">data_method_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data_method_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span> <span class="o">=</span> <span class="n">locus_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method_name</span> <span class="o">=</span> <span class="n">method_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_method_name</span> <span class="o">=</span> <span class="n">model_method_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># This value is used to uniformise lengths distributions in the comparison</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># This value is used to uniformise lengths distributions in the comparison</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_dataset</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># The MSISample provided for fitting. These samples are filtered before fit (see _usable_train_dataset)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_usable_train_dataset</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># The MSISample containing status information for the locus</span>

    <span class="k">def</span> <span class="nf">_get_min_max_len</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum and maximum length for the locus in the dataset.</span>

<span class="sd">        :param dataset: The list of MSISample.</span>
<span class="sd">        :type dataset: list</span>
<span class="sd">        :param method: The lengths distribution of the loci are extracted from the results of this method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :return: The list of MSISample.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">curr_spl</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
            <span class="n">locus_res</span> <span class="o">=</span> <span class="n">curr_spl</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
            <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_len</span><span class="p">,</span> <span class="n">locus_res</span><span class="o">.</span><span class="n">getMinLength</span><span class="p">())</span>
            <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_len</span><span class="p">,</span> <span class="n">locus_res</span><span class="o">.</span><span class="n">getMaxLength</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">min_len</span><span class="p">,</span> <span class="n">max_len</span>

    <span class="k">def</span> <span class="nf">_set_min_max_len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the minimum and maximum length for the locus in the dataset (train + test).&quot;&quot;&quot;</span>
        <span class="n">train_min</span><span class="p">,</span> <span class="n">train_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_min_max_len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_usable_train_dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_method_name</span><span class="p">)</span>
        <span class="n">test_min</span><span class="p">,</span> <span class="n">test_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_min_max_len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_method_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">train_min</span><span class="p">,</span> <span class="n">test_min</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">train_max</span><span class="p">,</span> <span class="n">test_max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return uniformised lengths distribution from the dataset.</span>

<span class="sd">        :param dataset: The list of MSISample.</span>
<span class="sd">        :type dataset: list</span>
<span class="sd">        :param method: The lengths distribution of the loci are extracted from the results of this method.</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :return: The uniformised lengths distribution. Rows are samples, columns are lengths and values are percentages of counts in the sample.</span>
<span class="sd">        :rtype: np.matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prct_matrix</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># rows are samples, columns are lengths and values are percentages of counts in the sample.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_min_max_len</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_spl</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
            <span class="n">locus_res</span> <span class="o">=</span> <span class="n">curr_spl</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
            <span class="n">prct_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">locus_res</span><span class="o">.</span><span class="n">getDensePrct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">prct_matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_test_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return uniformised lengths distribution for samples in test dataset.</span>

<span class="sd">        :return: The uniformised lengths distribution. Rows are samples, columns are lengths and values are percentages of counts in the sample.</span>
<span class="sd">        :rtype: np.matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_method_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_train_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return uniformised lengths distribution for samples in usable train dataset.</span>

<span class="sd">        :return: The uniformised lengths distribution. Rows are samples, columns are lengths and values are percentages of counts in the sample.</span>
<span class="sd">        :rtype: np.matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_usable_train_dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_method_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_train_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of labels for samples in usable train dataset.</span>

<span class="sd">        :return: The list of labels for samples in usable train dataset.</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">curr_spl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_usable_train_dataset</span><span class="p">:</span>
            <span class="n">locus_res</span> <span class="o">=</span> <span class="n">curr_spl</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model_method_name</span><span class="p">]</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locus_res</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

<div class="viewcode-block" id="LocusClassifier.fit"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusClassifier.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model using train_dataset as training data and their status as target values.</span>

<span class="sd">        :param train_dataset: The list of MSISample containing the locus to classify and in LocusRes the data of the selected method and the status ecpected.</span>
<span class="sd">        :type test_dataset: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_dataset</span> <span class="o">=</span> <span class="n">train_dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_usable_train_dataset</span> <span class="o">=</span> <span class="p">[</span><span class="n">spl</span> <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="n">train_dataset</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_method_name</span> <span class="ow">in</span> <span class="n">spl</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_train_data</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_train_labels</span><span class="p">())</span></div>

<div class="viewcode-block" id="LocusClassifier.predict"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusClassifier.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict the status of the locus in the list of samples.</span>

<span class="sd">        :param test_dataset: The list of MSISample containing the locus to classify and in LocusRes the data of the selected method. These samples must already be filtered, for eaxmple on count of elements in length distribution.</span>
<span class="sd">        :type test_dataset: list</span>
<span class="sd">        :return: The predicted class for the selected locus in each sample.</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span> <span class="o">=</span> <span class="n">test_dataset</span>
        <span class="n">test_min_len</span><span class="p">,</span> <span class="n">test_max_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_min_max_len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_method_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test_min_len</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span> <span class="ow">or</span> <span class="n">test_max_len</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train_dataset</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_test_data</span><span class="p">())</span></div>

<div class="viewcode-block" id="LocusClassifier.predict_proba"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusClassifier.predict_proba">[docs]</a>    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return estimated probabilities for the test_dataset.</span>

<span class="sd">        :param test_dataset: The list of MSISample containing the locus to classify and in LocusRes the data of the selected method. These samples must already be filtered, for eaxmple on count of elements in length distribution.</span>
<span class="sd">        :type test_dataset: list</span>
<span class="sd">        :return: The estimated probabilities for the test_dataset.</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span> <span class="o">=</span> <span class="n">test_dataset</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_test_data</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_get_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pred_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return confidence scores for the predictions of the test_dataset.</span>

<span class="sd">        :param pred_labels: The list of predicted status for the test_dataset.</span>
<span class="sd">        :type pred_labels: list</span>
<span class="sd">        :return: The scores for the predictions. The values are between 0 and 1.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">proba_idx_by_label</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">classes_</span><span class="p">)}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">proba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span><span class="p">)</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">spl_proba</span><span class="p">[</span><span class="n">proba_idx_by_label</span><span class="p">[</span><span class="n">spl_label</span><span class="p">]],</span> <span class="mi">6</span><span class="p">)</span> <span class="k">for</span> <span class="n">spl_proba</span><span class="p">,</span> <span class="n">spl_label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">pred_labels</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">scores</span>

<div class="viewcode-block" id="LocusClassifier.set_status"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.LocusClassifier.set_status">[docs]</a>    <span class="k">def</span> <span class="nf">set_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_dataset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set status and score for the selected locus in the list of samples.</span>

<span class="sd">        :param test_dataset: The list of MSISample containing the locus to classify and in LocusRes the data of the selected method. These samples must already be filtered, for eaxmple on count of elements in length distribution.</span>
<span class="sd">        :type test_dataset: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span> <span class="o">=</span> <span class="n">test_dataset</span>
        <span class="n">pred_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_dataset</span><span class="p">)</span>
        <span class="n">pred_scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_scores</span><span class="p">(</span><span class="n">pred_labels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pred_labels</span><span class="p">,</span> <span class="n">pred_scores</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_test_dataset</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sample</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>  <span class="c1"># If the method does not exist in locus results</span>
                <span class="n">sample</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">method_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">LocusRes</span><span class="p">(</span><span class="n">Status</span><span class="o">.</span><span class="n">none</span><span class="p">)</span>
            <span class="n">locus_res</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">locus_id</span><span class="p">]</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">method_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_method_name</span><span class="p">:</span>  <span class="c1"># If data used in prediction come from an other method</span>
                <span class="n">locus_res</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;data_source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_method_name</span>
            <span class="n">locus_res</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">label</span>
            <span class="n">locus_res</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">score</span></div></div>


<div class="viewcode-block" id="MSIReport"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSIReport">[docs]</a><span class="k">class</span> <span class="nc">MSIReport</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Read/write the JSON file used to store a list of MSISample.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="MSIReport.parse"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSIReport.parse">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">in_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of MSISample stored in a MSIReport file.</span>

<span class="sd">        :param in_path: Path to the file storing MSISamples (format: MSIReport).</span>
<span class="sd">        :type in_path: str</span>
<span class="sd">        :return: The list of MSISample.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spl_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">in_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">FH_in</span><span class="p">:</span>
            <span class="n">spl_data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">FH_in</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">MSISample</span><span class="o">.</span><span class="n">fromDict</span><span class="p">(</span><span class="n">curr_spl</span><span class="p">)</span> <span class="k">for</span> <span class="n">curr_spl</span> <span class="ow">in</span> <span class="n">spl_data</span><span class="p">]</span></div>

<div class="viewcode-block" id="MSIReport.write"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.MSIReport.write">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">msi_samples</span><span class="p">,</span> <span class="n">out_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the list of MSISample in a MSIReport file.</span>

<span class="sd">        :param msi_samples: The list of MSISample.</span>
<span class="sd">        :type msi_samples: list</span>
<span class="sd">        :param out_path: Path to the output file storing MSISamples (format: MSIReport).</span>
<span class="sd">        :type in_path: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">out_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">FH_out</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">msi_samples</span><span class="p">,</span> <span class="n">FH_out</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">toDict</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="getNbSupporting"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.getNbSupporting">[docs]</a><span class="k">def</span> <span class="nf">getNbSupporting</span><span class="p">(</span><span class="n">report</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;model&quot;</span><span class="p">,</span> <span class="n">loci</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of samples by locus class.</span>

<span class="sd">    :param in_report: List of MSISample.</span>
<span class="sd">    :type in_report: list()</span>
<span class="sd">    :param method: Evaluated method.</span>
<span class="sd">    :type method: str</span>
<span class="sd">    :param loci: List of evaluated loci.</span>
<span class="sd">    :type loci: list</span>
<span class="sd">    :return: The number of samples by locus class. Each item is dict with following keys: locus_name, locus_id, status and support.</span>
<span class="sd">    :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Init loci from report if the argument is None</span>
    <span class="k">if</span> <span class="n">loci</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">loci</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="n">report</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">locus_id</span> <span class="ow">in</span> <span class="n">spl</span><span class="o">.</span><span class="n">loci</span><span class="p">:</span>
                <span class="n">loci</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">locus_id</span><span class="p">)</span>
    <span class="c1"># Get count by status by locus</span>
    <span class="n">nb_by_locus</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">spl</span> <span class="ow">in</span> <span class="n">report</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">locus_id</span> <span class="ow">in</span> <span class="n">loci</span><span class="p">:</span>
            <span class="n">locus</span> <span class="o">=</span> <span class="n">spl</span><span class="o">.</span><span class="n">loci</span><span class="p">[</span><span class="n">locus_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">locus_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nb_by_locus</span><span class="p">:</span>
                <span class="n">nb_by_locus</span><span class="p">[</span><span class="n">locus_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;locus_name&quot;</span><span class="p">:</span> <span class="n">locus</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="s2">&quot;supp_by_status&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">elt</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">Status</span><span class="o">.</span><span class="n">authorizedValues</span><span class="p">()}</span>
                <span class="p">}</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">:</span>
                <span class="n">locus_status</span> <span class="o">=</span> <span class="n">locus</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">status</span>
                <span class="n">nb_by_locus</span><span class="p">[</span><span class="n">locus_id</span><span class="p">][</span><span class="s2">&quot;supp_by_status&quot;</span><span class="p">][</span><span class="n">locus_status</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># To list</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">locus_id</span><span class="p">,</span> <span class="n">locus_info</span> <span class="ow">in</span> <span class="n">nb_by_locus</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">status</span><span class="p">,</span> <span class="n">support</span> <span class="ow">in</span> <span class="n">locus_info</span><span class="p">[</span><span class="s2">&quot;supp_by_status&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s2">&quot;locus_id&quot;</span><span class="p">:</span> <span class="n">locus_id</span><span class="p">,</span>
                <span class="s2">&quot;locus_name&quot;</span><span class="p">:</span> <span class="n">locus_info</span><span class="p">[</span><span class="s2">&quot;locus_name&quot;</span><span class="p">],</span>
                <span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="n">status</span><span class="p">,</span>
                <span class="s2">&quot;support&quot;</span><span class="p">:</span> <span class="n">support</span>
            <span class="p">})</span>
    <span class="k">return</span> <span class="n">counts</span></div>


<div class="viewcode-block" id="getIncompleteModels"><a class="viewcode-back" href="../../../anacore.html#anacore.msi.base.getIncompleteModels">[docs]</a><span class="k">def</span> <span class="nf">getIncompleteModels</span><span class="p">(</span><span class="n">in_report</span><span class="p">,</span> <span class="n">min_support_model</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the list of locus class model with an unsufficient number of supporting samples.</span>

<span class="sd">    :param in_report: Path to a MSIReport file.</span>
<span class="sd">    :type in_report: str</span>
<span class="sd">    :param min_support_model: The minimum number of sample in locus class to validate the model.</span>
<span class="sd">    :type min_support_model: int</span>
<span class="sd">    :return: The list of locus class model with with an unsufficient number of supporting samples. Each item is dict with following keys: locus_name, locus_id, status and support.</span>
<span class="sd">    :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">incomplete_models</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">report</span> <span class="o">=</span> <span class="n">MSIReport</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">in_report</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">curr_model</span> <span class="ow">in</span> <span class="n">getNbSupporting</span><span class="p">(</span><span class="n">report</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;model&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">curr_model</span><span class="p">[</span><span class="s2">&quot;status&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Status</span><span class="o">.</span><span class="n">stable</span><span class="p">,</span> <span class="n">Status</span><span class="o">.</span><span class="n">unstable</span><span class="p">]</span> <span class="ow">and</span> <span class="n">curr_model</span><span class="p">[</span><span class="s2">&quot;support&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_support_model</span><span class="p">:</span>
            <span class="n">incomplete_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_model</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">incomplete_models</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, Frdric Escudi.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>